name: Lighthouse CI

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      url:
        description: "URL to run Lighthouse on"
        required: false
        default: "http://localhost:8080"

permissions:
  issues: write
  contents: read

jobs:
  lighthouse-audit:
    name: Lighthouse Performance Audit
    runs-on: ubuntu-latest

    # ğŸ‘‡ [ì¶”ê°€ 1] ì¡°ê±´ë¶€ ì‹¤í–‰ ë¡œì§
    # ìˆ˜ë™ ì‹¤í–‰ì´ê±°ë‚˜, ì»¤ë°‹ ë©”ì‹œì§€ì— íŠ¹ì • í‚¤ì›Œë“œê°€ í¬í•¨ë  ë•Œë§Œ ì‹¤í–‰
    if: |
      github.event_name == 'workflow_dispatch' ||
      contains(github.event.head_commit.message, 'feat') ||
      contains(github.event.head_commit.message, 'perf') ||
      contains(github.event.head_commit.message, 'refactor') ||
      contains(github.event.head_commit.message, '[lhci]')

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "pnpm"

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile

      - name: Build Project
        run: pnpm run build

      - name: Install Lighthouse CI
        run: npm install -g @lhci/cli@0.14.x

      - name: Run Lighthouse CI
        id: lighthouse
        continue-on-error: true
        run: |
          lhci autorun --collect.staticDistDir=./dist --collect.numberOfRuns=3

      # ê¸°ì¡´: ê¹ƒí—™ ì´ìŠˆì— ëŒ“ê¸€ ë‹¬ê¸°
      - name: Report Results to GitHub Issue
        if: always()
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const LHCI_DIR = '.lighthouseci';
            const THRESHOLDS = {
              LCP: { good: 2500, poor: 4000 },
              INP: { good: 200, poor: 500 },
              CLS: { good: 0.1, poor: 0.25 },
            };

            const getLatestReport = () => {
              try {
                const jsonReports = fs.readdirSync(LHCI_DIR).filter(f => f.endsWith('.json'));
                if (!jsonReports.length) return null;
                const latestReport = jsonReports.sort().reverse()[0];
                return JSON.parse(fs.readFileSync(path.join(LHCI_DIR, latestReport), 'utf8'));
              } catch (e) {
                console.error('Failed to read report:', e);
                return null;
              }
            };

            const formatScore = (val) => Math.round((val || 0) * 100);

            const getStatusIcon = (val, metric) => {
              if (!metric) return val >= 90 ? 'ğŸŸ¢' : val >= 50 ? 'ğŸŸ ' : 'ğŸ”´';
              const t = THRESHOLDS[metric];
              if (val <= t.good) return 'ğŸŸ¢';
              if (val <= t.poor) return 'ğŸŸ ';
              return 'ğŸ”´';
            };

            const formatMetricValue = (val, metric) => {
              if (val === undefined || val === null) return '-';
              if (metric === 'CLS') return val.toFixed(3);
              return `${(val / 1000).toFixed(2)}s`;
            };

            const generateFeedback = (webVitals, scores) => {
              let feedback = [];
              if (webVitals.LCP > THRESHOLDS.LCP.good) {
                feedback.push(`### âš ï¸ **LCP ìµœì í™” í•„ìš” (${formatMetricValue(webVitals.LCP, 'LCP')})**`);
                feedback.push(`- **ë¶„ì„**: ì´ˆê¸° ë¡œë”© ì†ë„ê°€ ëŠë¦½ë‹ˆë‹¤. Waterfall ì°¨íŠ¸ë‚˜ ë¦¬ì†ŒìŠ¤ ìš°ì„ ìˆœìœ„ë¥¼ í™•ì¸í•˜ì„¸ìš”.`);
              }
              if (webVitals.INP > THRESHOLDS.INP.good || scores.performance < 0.9) {
                 feedback.push(`### âš ï¸ **ë°˜ì‘ì„±(INP) ê°œì„  í•„ìš”**`);
                 feedback.push(`- **ë¶„ì„**: ì…ë ¥ ì§€ì—°ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ë©”ì¸ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ì‘ì—…ì„ í™•ì¸í•˜ì„¸ìš”.`);
              }
              if (webVitals.CLS > THRESHOLDS.CLS.good) {
                 feedback.push(`### âš ï¸ **ë ˆì´ì•„ì›ƒ ì•ˆì •ì„±(CLS) í™•ë³´ í•„ìš”**`);
              }
              if (feedback.length === 0) {
                feedback.push(`### âœ… **ì„±ëŠ¥ ìµœì í™” ëª©í‘œ ë‹¬ì„±**`);
              }
              return feedback.join('\n');
            };

            const report = getLatestReport();
            if (!report) return;

            const categories = report.categories || {};
            const audits = report.audits || {};

            const scores = {
              performance: categories.performance?.score,
              accessibility: categories.accessibility?.score,
              bestPractices: categories['best-practices']?.score,
            };

            const webVitals = {
              LCP: audits['largest-contentful-paint']?.numericValue,
              INP: audits['experimental-interaction-to-next-paint']?.numericValue ?? audits['interactive']?.numericValue,
              CLS: audits['cumulative-layout-shift']?.numericValue,
            };

            const now = new Date().toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });
            const feedbackMessage = generateFeedback(webVitals, scores);

            const body = `
            ## ğŸ“Š ì„±ëŠ¥ ë¶„ì„ ë¦¬í¬íŠ¸
            > ì¸¡ì • ì¼ì‹œ: ${now}

            ${feedbackMessage}

            ---

            ### ì¸¡ì • ê²°ê³¼ ìš”ì•½
            | ì¹´í…Œê³ ë¦¬ | ì ìˆ˜ | ìƒíƒœ |
            |:---:|:---:|:---|
            | **Performance** | **${formatScore(scores.performance)}** | ${getStatusIcon(formatScore(scores.performance))} |
            | **Accessibility** | **${formatScore(scores.accessibility)}** | ${getStatusIcon(formatScore(scores.accessibility))} |
            | **Best Practices** | **${formatScore(scores.bestPractices)}** | ${getStatusIcon(formatScore(scores.bestPractices))} |
            ### Core Web Vitals
            | ì§€í‘œ | ì¸¡ì •ê°’ | ìƒíƒœ |
            |:---:|:---:|:---|
            | **LCP** | ${formatMetricValue(webVitals.LCP, 'LCP')} | ${getStatusIcon(webVitals.LCP, 'LCP')} |
            | **INP** | ${formatMetricValue(webVitals.INP, 'INP')} | ${getStatusIcon(webVitals.INP, 'INP')} |
            | **CLS** | ${formatMetricValue(webVitals.CLS, 'CLS')} | ${getStatusIcon(webVitals.CLS, 'CLS')} |
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ì„±ëŠ¥ ë¶„ì„ ê²°ê³¼ [${now}]`,
              body: body,
              labels: ['lighthouse', 'performance']
            });

      # ğŸ‘‡ [ì¶”ê°€ 2] DB/APIë¡œ ê²°ê³¼ ì „ì†¡
      - name: Send Results to Database
        if: always() # ì´ìŠˆ ìƒì„± ì„±ê³µ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ ì‹¤í–‰
        uses: actions/github-script@v6
        env:
          # GitHub Repository Secretsì— DB_API_URLì„ ë“±ë¡í•´ì•¼ í•©ë‹ˆë‹¤!
          DB_API_URL: ${{ secrets.DB_API_URL }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // 1. URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ìŠ¤í‚µ
            if (!process.env.DB_API_URL) {
              console.log('âš ï¸ DB_API_URL secret is not set. Skipping DB upload.');
              return;
            }

            const LHCI_DIR = '.lighthouseci';

            // 2. ë¦¬í¬íŠ¸ ì½ê¸°
            let report;
            try {
              const jsonReports = fs.readdirSync(LHCI_DIR).filter(f => f.endsWith('.json'));
              if (!jsonReports.length) return;
              const latestReport = jsonReports.sort().reverse()[0];
              report = JSON.parse(fs.readFileSync(path.join(LHCI_DIR, latestReport), 'utf8'));
            } catch (e) {
              console.error('Failed to read report for DB:', e);
              return;
            }

            const categories = report.categories || {};
            const audits = report.audits || {};

            // 3. ì „ì†¡í•  ë°ì´í„° í˜ì´ë¡œë“œ êµ¬ì„±
            const payload = {
              timestamp: new Date().toISOString(),
              commit: context.sha,
              branch: context.ref.replace('refs/heads/', ''),
              scores: {
                performance: categories.performance?.score * 100,
                accessibility: categories.accessibility?.score * 100,
                bestPractices: categories['best-practices']?.score * 100,
                seo: categories.seo?.score * 100,
              },
              metrics: {
                lcp: audits['largest-contentful-paint']?.numericValue,
                inp: audits['interactive']?.numericValue,
                cls: audits['cumulative-layout-shift']?.numericValue,
                tbt: audits['total-blocking-time']?.numericValue,
              }
            };

            console.log('ğŸš€ Sending payload to DB:', JSON.stringify(payload, null, 2));

            // 4. API í˜¸ì¶œ (fetchëŠ” Node 18+ë¶€í„° ê¸°ë³¸ ì§€ì›, ì—¬ê¸°ì„  Node 20 ì‚¬ìš©í•˜ë¯€ë¡œ OK)
            try {
              const response = await fetch(process.env.DB_API_URL, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  // í•„ìš”ì‹œ ì¸ì¦ í—¤ë” ì¶”ê°€: 'Authorization': `Bearer ${process.env.DB_API_TOKEN}`
                },
                body: JSON.stringify(payload)
              });

              if (response.ok) {
                console.log('âœ… Successfully sent results to DB');
              } else {
                console.error('âŒ Failed to send results:', response.status, response.statusText);
                const text = await response.text();
                console.error('Response:', text);
              }
            } catch (error) {
              console.error('âŒ Network error sending to DB:', error);
            }
